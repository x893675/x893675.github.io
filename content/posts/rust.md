---
title: rust学习笔记
date: 2019-12-01T14:21:26+08:00
lastmod: 2019-12-01T14:21:26+08:00
author: hanamichi
cover: /img/rust.jpg
categories: ['编程语言学习']
tags: ['rust']
---

rust学习笔记及知识点记录

<!--more-->

- [变量](#变量)
  - [不可变变量](#不可变变量)
  - [可变变量](#可变变量)
  - [权衡变量定义](#权衡变量定义)
- [常量](#常量)
- [变量隐藏](#变量隐藏)
- [语句](#语句)
- [表达式](#表达式)
  - [块表达式](#块表达式)
  - [位置表达式](#位置表达式)
  - [值表达式](#值表达式)
- [注释](#注释)

## 变量

### 不可变变量

rust 中的变量默认是不可改变的 （immutable）

`let` 关键字用于定义变量，默认定义的是不可变变量：

```rust
fn main() {
    // 通过类型推导得到变量类型，因此可以不指定变量类型
    let a = 1;
    println!("{}",a);
    // 明确指定变量类型
    let b:bool = false;
    println!("{}",b);
}
```

**Rust 编译器保证，如果声明一个值不会变，它就真的不会变。这意味着当阅读和编写代码时，不需要追踪一个值如何和在哪可能会被改变，从而使得代码易于推导。**

### 可变变量

在变量名之前加 mut 来使其可变。除了允许改变值之外，mut 向读者表明了其他代码将会改变这个变量值的意图。

```rust
fn main() {
    let mut x = 4;
    println!("{}", x);
    x = 5;
    println!("{}", x);
}
```

### 权衡变量定义

- 使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快

- 对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的

- Rust 是 **静态类型**（*statically typed*）语言，也就是说在编译时就必须知道所有变量的类型。根据值及其使用方式，编译器通常可以推断出我们想要用的类型。当多种类型均有可能时，如使用 `parse` 将 `String` 转换为数字时，必须增加类型注解:

  ```rust
  let guess: u32 = "42".parse().expect("Not a number!");
  ```

## 常量

常量是绑定到一个名称的不允许改变的值。

常量与不可变变量的区别：

- 不允许对常量使用 `mut`
- 声明常量使用 `const` 关键字而不是 `let`，并且 *必须* 注明值的类型。
- 常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值

备注：rust的常量是必须在编译时明确赋值的。

```rust
const MAX_POINTS: u32 = 100_000;
```

## 变量隐藏

可以定义一个与之前变量同名的新变量，而新变量会 **隐藏(Shadowing)** 之前的变量。

可以用相同变量名称来隐藏一个变量，以及重复使用 `let` 关键字来多次隐藏，如下所示：

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

当再次使用 `let` 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字:

```rust
fn main(){
	let spaces = "   ";
    println!("{}", spaces);
    let spaces = spaces.len();
    println!("{}", spaces);
}
```

## 语句

**语句**（*Statements*）是执行一些操作但不返回值的指令。

语句分为两种：

- 声明语句

  用于声明各种语言项，包括声明变量，静态变量，常量，结构体，函数等，以及通过 extern 和 use 关键字引入包和模块等。

- 表达式语句

  特指以分号结束的表达式。此类表达式求值结果将会被舍弃，并总是返回单元类型`()`。

## 表达式

表达式（*Expressions*）计算并产生一个值

Rust 编译器在解析代码时：

- 如果遇到分号，就会继续往后面执行
- 如果遇到语句，就会执行语句
- 如果遇到表达式，就会对表达式求值
- 如果分号后面什么都没有，就会补上单元值`()`
- 当遇到函数时，就会将函数体的花括号识别为块表达式。

### 块表达式

块表达式是由一对花括号和一系列表达式组成的，它总是返回块中最后一个表达式的值。

### 位置表达式

位置表达式(Place Expression)一般叫做左值，是表示内存位置的表达式，有以下几类：

- 本地变量
- 静态变量
- 解引用 (* express)
- 数组索引 (expr[expr])
- 字段引用 (expr.field)
- 位置表达式组合

通过位置表达式可以对某个数据单元的内存进行读写。位置表达式可以用于赋值。

### 值表达式

值表达式(Value Expression)一般叫做右值，值表达式引用了某个存储单元地址中的数据。它相当于数据，只能进行读操作。

从语义角度来说，**位置表达式代表了持久性数据，值表达式代表了临时数据**。位置表达式一般有持久的状态，值表达式要不是字面量，要不就是表达式求值过程中创建的临时值。

## 注释

Rust的注释有两种：

1. 普通注释
   - `//` 对整行进行注释
   - `/* .. */` 对区块注释
2. 文档注释
   * `/// `生成库文档，一般用于函数或者结构体的说明，置于说明对象的上方
   * `//!` 也生成库文档，一般用于说明整个模块的功能，置于模块文件的头部
